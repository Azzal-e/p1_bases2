-- Script para crear las tablas del segundo esquema conceptual
-- en PostgreSQL
-- Eliminar tablas si ya existían
DROP TABLE IF EXISTS STORE CASCADE;
DROP TABLE IF EXISTS PERSON CASCADE;
DROP TABLE IF EXISTS PRODUCT CASCADE;
DROP TABLE IF EXISTS WORKS CASCADE;


CREATE TABLE STORE (
    CIF VARCHAR(9) PRIMARY KEY,
    NAME VARCHAR(50) NOT NULL,
    ADDRESS VARCHAR(200) NOT NULL
);

CREATE TABLE PERSON (
    DNI VARCHAR(9) PRIMARY KEY,
    FULL_NAME VARCHAR(50) NOT NULL,
    FECHA_DE_NACIMIENTO DATE NOT NULL,
    PHONE VARCHAR(15) NOT NULL CHECK (PHONE SIMILAR TO '^[0-9]{9}$'),
    EMAIL VARCHAR(100) UNIQUE CHECK (EMAIL SIMILAR TO '%@%.%') ,
    GENDER VARCHAR(10) CHECK (GENDER IN ('HOMBRE', 'MUJER', 'OTRO')),
    IS_EMPLOYEE BOOLEAN NOT NULL,
    IS_CLIENT BOOLEAN NOT NULL,
    HAS_MEMBER_CARD BOOLEAN,
    EMPLOYEE_NUMBER INT UNIQUE,
    NUMBER_OF_SALES INT, 
   
    CONSTRAINT CHECK_DNI_LENGTH CHECK (LENGTH(DNI) = 9),
    CONSTRAINT CHECK_NUMBER_OF_SALES CHECK (NUMBER_OF_SALES IS NULL OR NUMBER_OF_SALES >= 0),
    CONSTRAINT CHECK_ESPECIALTY_EMPLOYEE CHECK (IS_EMPLOYEE = TRUE AND 
                                                HAS_MEMBER_CARD IS NULL AND
                                                NUMBER_OF_SALES IS NOT NULL AND
                                                EMPLOYEE_NUMBER IS NOT NULL),
    CONSTRAINT CHECK_ESPECIALTY_CLIENT CHECK (IS_CLIENT = TRUE AND 
                                                HAS_MEMBER_CARD IS NOT NULL AND
                                                NUMBER_OF_SALES IS NULL AND
                                                EMPLOYEE_NUMBER IS NULL)
);

CREATE TABLE PRODUCT (
    ID SERIAL PRIMARY KEY,
    NAME VARCHAR(50) NOT NULL,
    PRICE NUMERIC(10, 2) NOT NULL,
    CIF_STORE VARCHAR(9) NOT NULL,
    DESCRIPTION VARCHAR(200),
    DNI_SELLER VARCHAR(9),
    DNI_BUYER VARCHAR(9),

    CONSTRAINT CHECK_PRICE CHECK (PRICE > 0),
    CONSTRAINT CHECK_NAME CHECK (NAME <> ''),
    CONSTRAINT CHECK_CIF_STORE_LENGTH CHECK (LENGTH(CIF_STORE) = 9),
    CONSTRAINT CHECK_DNI_SELLER_LENGTH CHECK (LENGTH(DNI_SELLER) = 9),
    CONSTRAINT CHECK_DNI_BUYER_LENGTH CHECK (LENGTH(DNI_BUYER) = 9),
    CONSTRAINT CHECK_DIFERENT_BUYER_SELLER CHECK (DNI_SELLER <> DNI_BUYER),
    
    CONSTRAINT FK_STORE FOREIGN KEY (CIF_STORE) REFERENCES STORE(CIF) ON DELETE CASCADE,
    CONSTRAINT FK_SELLER FOREIGN KEY (DNI_SELLER) REFERENCES PERSON(DNI) ON DELETE SET NULL,
    CONSTRAINT FK_BUYER FOREIGN KEY (DNI_BUYER) REFERENCES PERSON(DNI) ON DELETE SET NULL
);

CREATE TABLE WORKS (
    DNI VARCHAR(9) NOT NULL,
    CIF_STORE VARCHAR(9) NOT NULL,

    CONSTRAINT CHECK_DNI_LENGTH CHECK (LENGTH(DNI) = 9),
    CONSTRAINT CHECK_CIF_STORE_LENGTH CHECK (LENGTH(CIF_STORE) = 9),
    
    PRIMARY KEY (DNI, CIF_STORE),
    CONSTRAINT FK_WORKER FOREIGN KEY (DNI) REFERENCES PERSON(DNI) ON DELETE CASCADE,
    CONSTRAINT FK_STORE_WORK FOREIGN KEY (CIF_STORE) REFERENCES STORE(CIF) ON DELETE CASCADE
);

-- ATRIBUTOS DERIVADOS

-- CREAR UNA VISTA PARA CALCULAR LA EDAD DE LAS PERSONAS BASADA EN SU FECHA DE NACIMIENTO
CREATE OR REPLACE VIEW PERSON_AGE AS
SELECT 
    DNI,
    FULL_NAME,
    DATE_PART('year', AGE(FECHA_DE_NACIMIENTO)) AS AGE
FROM 
    PERSON;



-- RESTRICCIONES
-- UN EMPLEADO SOLO PUEDE VENDER UN PRODUCTO SI ES DE SU TIENDA
-- TRIGGER: PRODUCT_BEFORE_INSERT
CREATE OR REPLACE FUNCTION check_employee_store()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.CIF_STORE IS NOT NULL AND NEW.DNI_SELLER IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM WORKS WHERE DNI = NEW.DNI_SELLER AND CIF_STORE = NEW.CIF_STORE) THEN
            RAISE EXCEPTION 'El vendedor no trabaja en la tienda del producto';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_employee_store_trigger
BEFORE INSERT ON PRODUCT
FOR EACH ROW
EXECUTE FUNCTION check_employee_store();

-- EL DNI DEL VENDEDOR DE UN PRODUCTO DEBE ESTAR ASOCIADO A UNA PERSONA EMPLEADO
-- TRIGGER: PRODUCT_BEFORE_INSERT
CREATE OR REPLACE FUNCTION check_seller_exists()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.DNI_SELLER IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM PERSON WHERE DNI = NEW.DNI_SELLER AND IS_EMPLOYEE = TRUE) THEN
            RAISE EXCEPTION 'El vendedor no es un empleado';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

cREATE TRIGGER check_is_employee_trigger
BEFORE INSERT ON PRODUCT
FOR EACH ROW
EXECUTE FUNCTION check_seller_exists();

-- El DNI DEL COMPRADOR DE UN PRODUCTO DEBE ESTAR ASOCIADO A UNA PERSONA CLIENTE
-- TRIGGER: PRODUCT_BEFORE_INSERT
CREATE OR REPLACE FUNCTION check_buyer_exists()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.DNI_BUYER IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM PERSON WHERE DNI = NEW.DNI_BUYER AND IS_CLIENT = TRUE) THEN
            RAISE EXCEPTION 'El comprador no es un cliente';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_buyer_exists_trigger
BEFORE INSERT ON PRODUCT
FOR EACH ROW
EXECUTE FUNCTION check_buyer_exists();

-- El dni de una persona en WORKS debe estar asociado a un empleado
-- TRIGGER: WORKS_BEFORE_INSERT
CREATE OR REPLACE FUNCTION check_employee_exists()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM PERSON WHERE DNI = NEW.DNI AND IS_EMPLOYEE = TRUE) THEN
        RAISE EXCEPTION 'El DNI no está asociado a un empleado';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_employee_exists_trigger
BEFORE INSERT ON WORKS
FOR EACH ROW
EXECUTE FUNCTION check_employee_exists();

-- Poner a 0 el número de ventas de un empleado al insertarlo
-- TRIGGER: PERSON_BEFORE_INSERT
CREATE OR REPLACE FUNCTION set_sales_to_zero()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.IS_EMPLOYEE = TRUE THEN
        NEW.NUMBER_OF_SALES := 0;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_sales_to_zero_trigger
BEFORE INSERT ON PERSON
FOR EACH ROW
EXECUTE FUNCTION set_sales_to_zero();

-- Actualizar el número de ventas de un empleado al insertar un producto
-- TRIGGER: PRODUCT_AFTER_INSERT
CREATE OR REPLACE FUNCTION update_sales_count()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.DNI_SELLER IS NOT NULL THEN
        UPDATE PERSON SET NUMBER_OF_SALES = NUMBER_OF_SALES + 1 WHERE DNI = NEW.DNI_SELLER;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_sales_count_trigger
AFTER INSERT ON PRODUCT
FOR EACH ROW
EXECUTE FUNCTION update_sales_count();
-- Actualizar el número de ventas de un empleado al eliminar un producto
-- TRIGGER: PRODUCT_AFTER_DELETE
CREATE OR REPLACE FUNCTION decrement_sales_count()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.DNI_SELLER IS NOT NULL THEN
        UPDATE PERSON SET NUMBER_OF_SALES = NUMBER_OF_SALES - 1 WHERE DNI = OLD.DNI_SELLER;
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER decrement_sales_count_trigger
AFTER DELETE ON PRODUCT
FOR EACH ROW
EXECUTE FUNCTION decrement_sales_count();

